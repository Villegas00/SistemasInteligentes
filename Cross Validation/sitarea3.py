# -*- coding: utf-8 -*-
"""SITarea3

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/#fileId=https%3A//storage.googleapis.com/kaggle-colab-exported-notebooks/sitarea3-ec5fa3e9-de09-448d-95c6-74da68806b2e.ipynb%3FX-Goog-Algorithm%3DGOOG4-RSA-SHA256%26X-Goog-Credential%3Dgcp-kaggle-com%2540kaggle-161607.iam.gserviceaccount.com/20240611/auto/storage/goog4_request%26X-Goog-Date%3D20240611T025625Z%26X-Goog-Expires%3D259200%26X-Goog-SignedHeaders%3Dhost%26X-Goog-Signature%3D004eb5661e39a0abac0b8191e7c77cbae67fc3c4f332e631040f7c01d665c4532b459d986eca37a9a29015996c27e88aaad7452f9036a4445bb8bf7ca80e811c05260d27f5b3ff66bd62e8bf73da335127a8311c461fd5416ec29d27cf044df58f145d202a3f51af9f7864c7dcb538ed365bf3f134ddc1be8e78783da78c8461dbad394e3e9e3e14c1dfe79c32c3150552ad972df6a70f55b1a571ab7190782bd3c845cd96bcf0f11798b0846bf6640fd957d355b40395a88707521cfd7c1fd25c59e8e525c3f34a1a40e20e1c28d204bbf7c125d2bfd0ab3c79ec6e385e8820f4ebbe92d8f13ef1d5e0118c1d6500118eb7f1b99ee630cdaf9889b15f92c21a
"""

# This Python 3 environment comes with many helpful analytics libraries installed
# It is defined by the kaggle/python Docker image: https://github.com/kaggle/docker-python
# For example, here's several helpful packages to load

import numpy as np # linear algebra
import pandas as pd # data processing, CSV file I/O (e.g. pd.read_csv)

# Input data files are available in the read-only "../input/" directory
# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory

import os
for dirname, _, filenames in os.walk('/kaggle/input'):
    for filename in filenames:
        print(os.path.join(dirname, filename))

# You can write up to 20GB to the current directory (/kaggle/working/) that gets preserved as output when you create a version using "Save & Run All"
# You can also write temporary files to /kaggle/temp/, but they won't be saved outside of the current session

"""Logistic Regression"""

import numpy as np
import pandas as pd
df = pd.read_csv(../input/02-titanic/02-titanic.csv)
df.drop('Ticket', axis=1, inplace=True)
df.drop('Name', axis=1, inplace=True)
df.drop('Cabin', axis=1, inplace=True)
X = df.drop(['Survived'], axis=1).values
y = df['Survived']
df['Age'] = df['Age'].astype(float).fillna(df['Age'].mean()).astype(int)
from sklearn.model_selection import train_test_split
X_train, X_test , y_train, y_test = train_test_split(X,y,test_size=0.2,random_state=27)
from sklearn.linear_model import LogisticRegression
l_g = LogisticRegression(max_iter = 800)
from sklearn.model_selection import KFold
from sklearn.base import clone
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score
import statistics

    kf = KFold(n_splits=10,shuffle=True, random_state=42)
    acs_folds = []
    ps_folds = []
    rs_folds = []
    f_folds = []
    for train_index, test_index in kf.split(X):
        cloned_clf = clone(model) #clona el clasificador


        X_train, X_test = X[train_index], X[test_index]
        y_train, y_test = y[train_index], y[test_index]
        cloned_clf.fit(X_train, y_train)
        y_pred = cloned_clf.predict(X_test)
        acs = accuracy_score(y_test,y_pred)
        ps = precision_score(y_test,y_pred)
        rs = recall_score(y_test,y_pred)
        f1 = f1_score(y_test,y_pred)

        acs_folds.append(acs)
        ps_folds.append(ps)
        rs_folds.append(rs)
        f_folds.append(f1)

        print('accuracy:', acs,'precision:',ps,'recall:',rs, 'f-score', f1)

    print('\nMean accuracy:', sum(acs_folds)/len(acs_folds))
    print('Standard deviation:',statistics.stdev(acs_folds,))

    model.fit(X_train, y_train)
    RocCurveDisplay.from_estimator(model, X_test, y_test)
cross_validation(l_g, X_train,X_test,y_train,y_test,X,y)

"""Desicion Tree"""

import numpy as np
import pandas as pd
df = pd.read_csv(../input/02-titanic/02-titanic.csv)
df.drop('Ticket', axis=1, inplace=True)
df.drop('Name', axis=1, inplace=True)
df.drop('Cabin', axis=1, inplace=True)
X = df.drop(['Survived'], axis=1).values
y = df['Survived']
df['Age'] = df['Age'].astype(float).fillna(df['Age'].mean()).astype(int)
from sklearn.model_selection import train_test_split
X_train, X_test , y_train, y_test = train_test_split(X,y,test_size=0.2,random_state=27)
from sklearn.tree import DesicionTreeClassifier
tree= DesicionTreeClassifier()
from sklearn.model_selection import KFold
from sklearn.base import clone
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score
import statistics

    kf = KFold(n_splits=10,shuffle=True, random_state=42)
    acs_folds = []
    ps_folds = []
    rs_folds = []
    f_folds = []
    for train_index, test_index in kf.split(X):
        cloned_clf = clone(model) #clona el clasificador


        X_train, X_test = X[train_index], X[test_index]
        y_train, y_test = y[train_index], y[test_index]
        cloned_clf.fit(X_train, y_train)
        y_pred = cloned_clf.predict(X_test)
        acs = accuracy_score(y_test,y_pred)
        ps = precision_score(y_test,y_pred)
        rs = recall_score(y_test,y_pred)
        f1 = f1_score(y_test,y_pred)

        acs_folds.append(acs)
        ps_folds.append(ps)
        rs_folds.append(rs)
        f_folds.append(f1)

        print('accuracy:', acs,'precision:',ps,'recall:',rs, 'f-score', f1)

    print('\nMean accuracy:', sum(acs_folds)/len(acs_folds))
    print('Standard deviation:',statistics.stdev(acs_folds,))

    model.fit(X_train, y_train)
    RocCurveDisplay.from_estimator(model, X_test, y_test)
cross_validation(tree, X_train,X_test,y_train,y_test,X,y)

"""Rbf"""

import numpy as np
import pandas as pd
df = pd.read_csv(../input/02-titanic/02-titanic.csv)
df.drop('Ticket', axis=1, inplace=True)
df.drop('Name', axis=1, inplace=True)
df.drop('Cabin', axis=1, inplace=True)
X = df.drop(['Survived'], axis=1).values
y = df['Survived']
df['Age'] = df['Age'].astype(float).fillna(df['Age'].mean()).astype(int)
from sklearn.model_selection import train_test_split
X_train, X_test , y_train, y_test = train_test_split(X,y,test_size=0.2,random_state=27)
from sklearn.svm import SVC
rbf= SVC(kernel='rbf')
from sklearn.model_selection import KFold
from sklearn.base import clone
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score
import statistics

    kf = KFold(n_splits=10,shuffle=True, random_state=42)
    acs_folds = []
    ps_folds = []
    rs_folds = []
    f_folds = []
    for train_index, test_index in kf.split(X):
        cloned_clf = clone(model) #clona el clasificador


        X_train, X_test = X[train_index], X[test_index]
        y_train, y_test = y[train_index], y[test_index]
        cloned_clf.fit(X_train, y_train)
        y_pred = cloned_clf.predict(X_test)
        acs = accuracy_score(y_test,y_pred)
        ps = precision_score(y_test,y_pred)
        rs = recall_score(y_test,y_pred)
        f1 = f1_score(y_test,y_pred)

        acs_folds.append(acs)
        ps_folds.append(ps)
        rs_folds.append(rs)
        f_folds.append(f1)

        print('accuracy:', acs,'precision:',ps,'recall:',rs, 'f-score', f1)

    print('\nMean accuracy:', sum(acs_folds)/len(acs_folds))
    print('Standard deviation:',statistics.stdev(acs_folds,))

    model.fit(X_train, y_train)
    RocCurveDisplay.from_estimator(model, X_test, y_test)
cross_validation(rbf, X_train,X_test,y_train,y_test,X,y)

"""Linear"""

import numpy as np
import pandas as pd
df = pd.read_csv(../input/02-titanic/02-titanic.csv)
df.drop('Ticket', axis=1, inplace=True)
df.drop('Name', axis=1, inplace=True)
df.drop('Cabin', axis=1, inplace=True)
X = df.drop(['Survived'], axis=1).values
y = df['Survived']
df['Age'] = df['Age'].astype(float).fillna(df['Age'].mean()).astype(int)
from sklearn.model_selection import train_test_split
X_train, X_test , y_train, y_test = train_test_split(X,y,test_size=0.2,random_state=27)
from sklearn.svm import SVC
linear= SVC(kernel='linear')
from sklearn.model_selection import KFold
from sklearn.base import clone
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score
import statistics

    kf = KFold(n_splits=10,shuffle=True, random_state=42)
    acs_folds = []
    ps_folds = []
    rs_folds = []
    f_folds = []
    for train_index, test_index in kf.split(X):
        cloned_clf = clone(model) #clona el clasificador


        X_train, X_test = X[train_index], X[test_index]
        y_train, y_test = y[train_index], y[test_index]
        cloned_clf.fit(X_train, y_train)
        y_pred = cloned_clf.predict(X_test)
        acs = accuracy_score(y_test,y_pred)
        ps = precision_score(y_test,y_pred)
        rs = recall_score(y_test,y_pred)
        f1 = f1_score(y_test,y_pred)

        acs_folds.append(acs)
        ps_folds.append(ps)
        rs_folds.append(rs)
        f_folds.append(f1)

        print('accuracy:', acs,'precision:',ps,'recall:',rs, 'f-score', f1)

    print('\nMean accuracy:', sum(acs_folds)/len(acs_folds))
    print('Standard deviation:',statistics.stdev(acs_folds,))

    model.fit(X_train, y_train)
    RocCurveDisplay.from_estimator(model, X_test, y_test)
cross_validation(linear, X_train,X_test,y_train,y_test,X,y)

"""Neural Network"""

import numpy as np
import pandas as pd
df = pd.read_csv(../input/02-titanic/02-titanic.csv)
df.drop('Ticket', axis=1, inplace=True)
df.drop('Name', axis=1, inplace=True)
df.drop('Cabin', axis=1, inplace=True)
X = df.drop(['Survived'], axis=1).values
y = df['Survived']
df['Age'] = df['Age'].astype(float).fillna(df['Age'].mean()).astype(int)
from sklearn.model_selection import train_test_split
X_train, X_test , y_train, y_test = train_test_split(X,y,test_size=0.2,random_state=27)
from sklearn.neural_network import MLPClassifier
n_n= MLPClassifier (hidden_layer_sizes=(10,10,10,10), max_iter=100)
from sklearn.model_selection import KFold
from sklearn.base import clone
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score
import statistics

    kf = KFold(n_splits=10,shuffle=True, random_state=42)
    acs_folds = []
    ps_folds = []
    rs_folds = []
    f_folds = []
    for train_index, test_index in kf.split(X):
        cloned_clf = clone(model) #clona el clasificador


        X_train, X_test = X[train_index], X[test_index]
        y_train, y_test = y[train_index], y[test_index]
        cloned_clf.fit(X_train, y_train)
        y_pred = cloned_clf.predict(X_test)
        acs = accuracy_score(y_test,y_pred)
        ps = precision_score(y_test,y_pred)
        rs = recall_score(y_test,y_pred)
        f1 = f1_score(y_test,y_pred)

        acs_folds.append(acs)
        ps_folds.append(ps)
        rs_folds.append(rs)
        f_folds.append(f1)

        print('accuracy:', acs,'precision:',ps,'recall:',rs, 'f-score', f1)

    print('\nMean accuracy:', sum(acs_folds)/len(acs_folds))
    print('Standard deviation:',statistics.stdev(acs_folds,))

    model.fit(X_train, y_train)
    RocCurveDisplay.from_estimator(model, X_test, y_test)
cross_validation(n_n, X_train,X_test,y_train,y_test,X,y)

"""Tuve problemas para correrlos, ya que me aparecia un error en el archivo, que no era válido. Por lo que no pude corroborar cual era mejor"""