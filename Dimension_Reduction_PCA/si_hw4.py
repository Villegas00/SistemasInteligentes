# -*- coding: utf-8 -*-
"""SI_HW4

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/#fileId=https%3A//storage.googleapis.com/kaggle-colab-exported-notebooks/si-hw4-cb854ff6-65c2-4f48-a313-2b5c288223e5.ipynb%3FX-Goog-Algorithm%3DGOOG4-RSA-SHA256%26X-Goog-Credential%3Dgcp-kaggle-com%2540kaggle-161607.iam.gserviceaccount.com/20240611/auto/storage/goog4_request%26X-Goog-Date%3D20240611T025929Z%26X-Goog-Expires%3D259200%26X-Goog-SignedHeaders%3Dhost%26X-Goog-Signature%3D0a8238b4f18ea847a7dce509e98ec4de51c757158af8f22dc0af0f983bb05446e2a8760c03e46d0d8f50e8d3f5b28ad4de2917427fbcfbb66ade79aa2d5a0396d841d54f89e6685008a2487019db47779182123f55b788de7cac226ef7e4ce89fc3255da1aa7e90e920727494134d11d726a4189eea29d122a51ace63a73963940b55aea7379a18b5fb190ca5babac5d8c6e94c890bec33ba97a50ee29f61f73cb27196b176d18f132c847e9740fc562d21a52945a90b372041642b2671f2aeaeba4e3c8a3d8df03e999e906ed4d05abb29513136910b0e5bc6e7613ebd76938532b1440c737d78734f446990b726de28ec2a6bd979e583a4374971abb4702fe
"""

# IMPORTANT: RUN THIS CELL IN ORDER TO IMPORT YOUR KAGGLE DATA SOURCES
# TO THE CORRECT LOCATION (/kaggle/input) IN YOUR NOTEBOOK,
# THEN FEEL FREE TO DELETE THIS CELL.
# NOTE: THIS NOTEBOOK ENVIRONMENT DIFFERS FROM KAGGLE'S PYTHON
# ENVIRONMENT SO THERE MAY BE MISSING LIBRARIES USED BY YOUR
# NOTEBOOK.

import os
import sys
from tempfile import NamedTemporaryFile
from urllib.request import urlopen
from urllib.parse import unquote, urlparse
from urllib.error import HTTPError
from zipfile import ZipFile
import tarfile
import shutil

CHUNK_SIZE = 40960
DATA_SOURCE_MAPPING = '03-train-mnist:https%3A%2F%2Fstorage.googleapis.com%2Fkaggle-data-sets%2F2495339%2F4233775%2Fbundle%2Farchive.zip%3FX-Goog-Algorithm%3DGOOG4-RSA-SHA256%26X-Goog-Credential%3Dgcp-kaggle-com%2540kaggle-161607.iam.gserviceaccount.com%252F20240611%252Fauto%252Fstorage%252Fgoog4_request%26X-Goog-Date%3D20240611T025929Z%26X-Goog-Expires%3D259200%26X-Goog-SignedHeaders%3Dhost%26X-Goog-Signature%3D440b2d4cd9f121fe4ee1a4dffe7cc3bbc09c846344a802448004c4ce8c0701cd125b4d0512f2e7d2304abdb878535f624caff9a56c15fed452d48312cb36759054999b16c7a150b9044d626d83f0c825b42c4450f19abca752a6095fe9f10de9e2327c68f4e1ddca712fca20e00aa4036954d61d1b6532c1b36e708a084a0f3bffbd7d1c96e8c675b33b0e1137aee0d1f25fe81d8c0fc67e706f917dacf85c895a85fc6b8c9ca716bd9129f02b9f8cfdac214ef049b6631f7ef38ee8fa401663eb42544df77a419fa10fe4ebf8f9045a561f20d66d61a0ca45ba2b03faa01e6b038a5327dcc09d4c6456b0d3ba1333895ede9b973e1c95db938b2913e74127cd'

KAGGLE_INPUT_PATH='/kaggle/input'
KAGGLE_WORKING_PATH='/kaggle/working'
KAGGLE_SYMLINK='kaggle'

!umount /kaggle/input/ 2> /dev/null
shutil.rmtree('/kaggle/input', ignore_errors=True)
os.makedirs(KAGGLE_INPUT_PATH, 0o777, exist_ok=True)
os.makedirs(KAGGLE_WORKING_PATH, 0o777, exist_ok=True)

try:
  os.symlink(KAGGLE_INPUT_PATH, os.path.join("..", 'input'), target_is_directory=True)
except FileExistsError:
  pass
try:
  os.symlink(KAGGLE_WORKING_PATH, os.path.join("..", 'working'), target_is_directory=True)
except FileExistsError:
  pass

for data_source_mapping in DATA_SOURCE_MAPPING.split(','):
    directory, download_url_encoded = data_source_mapping.split(':')
    download_url = unquote(download_url_encoded)
    filename = urlparse(download_url).path
    destination_path = os.path.join(KAGGLE_INPUT_PATH, directory)
    try:
        with urlopen(download_url) as fileres, NamedTemporaryFile() as tfile:
            total_length = fileres.headers['content-length']
            print(f'Downloading {directory}, {total_length} bytes compressed')
            dl = 0
            data = fileres.read(CHUNK_SIZE)
            while len(data) > 0:
                dl += len(data)
                tfile.write(data)
                done = int(50 * dl / int(total_length))
                sys.stdout.write(f"\r[{'=' * done}{' ' * (50-done)}] {dl} bytes downloaded")
                sys.stdout.flush()
                data = fileres.read(CHUNK_SIZE)
            if filename.endswith('.zip'):
              with ZipFile(tfile) as zfile:
                zfile.extractall(destination_path)
            else:
              with tarfile.open(tfile.name) as tarfile:
                tarfile.extractall(destination_path)
            print(f'\nDownloaded and uncompressed: {directory}')
    except HTTPError as e:
        print(f'Failed to load (likely expired) {download_url} to path {destination_path}')
        continue
    except OSError as e:
        print(f'Failed to load {download_url} to path {destination_path}')
        continue

print('Data source import complete.')

"""# Dimension Reduction with PCA on MNIST images

### i)
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import sklearn

def PCA_fit(X):
    centroid=np.mean(X,axis=0)
    sigma = np.dot((X- centroid).T, X-centroid)/X.shape[0]
    eigvals, eigvecs = np.linalg.eigh(sigma)
    return centroid, eigvals, eigvecs

def PCA_transform(Z, centroid, eigvacs, n):
    return np.dot(Z-centroid,eigvecs[:, -n:])

df = pd.read_csv('../input/03-train-mnist/03-train-mnist.csv', low_memory=False)
x = df.drop(['label'], axis=1)
y = df['label'].values.flatten()

train_data = np.array(x)
train_label = np.array(y)

digit_index= np.logical_or(train_label == 4,train_label == 7)
digit_index= np.logical_or(digit_index,train_label == 8)

X=train_data[digit_index]
n = X.shape[1]
centroid, eigvals, eigvecs = PCA_fit(X)

"""### ii)"""

total_variance = np.cumsum(eigvals[:-n:-1])/np.sum(eigvals[:-n:-1])

porcent = 0.98
j=0
for i in total_variance:
    j = j+1
    if i == total_variance.flat[np.abs(total_variance-porcent).argmin()]:
        print(j)

plt.figure()
plt.plot(eigvals[:-n:-1], 'rd')

"""#### At least how many dimensions will you have to use in PCA in order to keep 98 percent of the total variance in data? 244

### iii)
"""

plt.figure(figsize=(7,7))
idx=100

y_plot= np.dot(eigvecs.T, eigvecs)

data = y_plot[2].reshape(28,28)
plt.imshow(data, cmap = plt.cm.gray)
plt.show()
data = y_plot[10].reshape(28,28)
plt.imshow(data, cmap = plt.cm.gray)
plt.show()
data = y_plot[50].reshape(28,28)
plt.imshow(data, cmap = plt.cm.gray)
plt.show()
data = y_plot[100].reshape(28,28)
plt.imshow(data, cmap = plt.cm.gray)
plt.show()
data = y_plot[500].reshape(28,28)
plt.imshow(data, cmap = plt.cm.gray)
plt.show()

